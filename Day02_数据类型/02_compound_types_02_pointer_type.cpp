//
// Created by 梁俊可 on 2025/10/23.
//
/*
   --------------------------01、堆和栈-----------------------------------------
   堆和栈
       1、内存分配方式
            栈：
                静态分配内存，由编译器分配，由编译器释放，速度快，内存占用小，内存连续。
            堆：
                动态分配内存，由new关键字分配，由delete关键字释放，占用内存大，速度慢。
       2、生命周期
            栈：
                放在栈中的数据，生命周期是函数调用结束，栈空间被回收。
            堆：
                放在堆中的数据，生命周期是new关键字分配的，堆中的数据会一直存在，直到delete关键字释放。
        3、存储数据类型
            栈：
                栈中类型数据有：局部变量、全局变量、栈中的对象、栈中的数组、栈中的函数等。
            堆：
                堆中的类型数据有：对象、数组、函数等。
            对象
                栈对象：MyClass obj; - 自动构造和析构    ------->类似变量的定义
                堆对象：MyClass* obj = new MyClass(); - 需要手动 delete
            数组
                栈数组：int arr[100]; - 大小必须在编译时确定
                堆数组：int* arr = new int[100]; - 大小可以在运行时确定
            函数
                栈函数：函数本身通常在代码段，但局部变量在栈上
                堆函数：函数本身不存储在堆上，但函数中动态分配的数据在堆上
        3、存储位置
            栈：
                内存连续，由系统自动管理
                大小有限制（通常几MB）
            堆：
                内存不连续，通过链表等方式管理
                大小受限于系统可用内存
        4、使用场景
            栈：
                存储局部变量和函数参数
                递归调用时保存函数状态
                临时数据的快速存取
                小规模、生命周期短的数据
            堆：
                大型数据结构的动态分配
                生命周期需要跨越函数调用的数据
                运行时才能确定大小的数据
                需要长期存在的对象
                多线程间共享的数据

        5、引申——数据段
            数据段既不在堆上也不在栈上，而是独立的内存区域。
            1. 数据段的特点
                独立区域：数据段是进程内存布局中的一个独立段
                静态分配：在程序编译时就确定大小
                全局可见：整个程序运行期间都存在
            2. 与堆和栈的区别
                堆：动态分配，运行时增长
                栈：函数调用时分配，函数结束时回收
                数据段：程序启动时分配，程序结束时回收
            3. 数据段存储的内容
                全局变量：int globalVar;
                静态变量：static int staticVar;
                常量数据：const int CONSTANT = 100;
                初始化数据：.data 段
                未初始化数据：.bss 段
*/

/*
  --------------------------02、cpp高级数据类型-----------------------------------------
      1. 标准库容器
          序列容器：
              std::vector：动态数组
              std::list：双向链表
              std::deque：双端队列
              std::forward_list：单向链表
          关联容器：
              std::map：有序映射表
              std::set：有序集合
              std::multimap：多重映射表
              std::multiset：多重集合
          无序关联容器：
              std::unordered_map：哈希映射表
              std::unordered_set：哈希集合
      2. 智能指针
              std::unique_ptr：独占所有权的智能指针
              std::shared_ptr：共享所有权的智能指针
              std::weak_ptr：弱引用智能指针
      3. 字符串类型
              std::string：字符字符串
              std::wstring：宽字符串
      4. 函数对象
              std::function：通用函数包装器
              Lambda表达式：匿名函数
      5. 其他高级类型
              std::tuple：元组
              std::pair：二元组
              std::array：固定大小数组
              std::bitset：位集
*/

/*
    --------------------------03、指针类型-----------------------------------------
    1.指针类型
        指针的本质是一种数据类型，它可以保存一个内存地址。
        但是指针的类型由指针所指向的数据类型决定。
        指针的类型:T *
        指针的作用是访问内存中的数据。
    2.判断指针指向区域的方法
        栈指针：通常指向局部变量、函数参数等。
        堆指针：通过 new、malloc 等动态分配函数创建的指针。
        代码段指针：指向函数地址的指针（如 function pointer）。
    3.注意事项
        指针本身的存储位置与其指向的内存区域无关。
        同一指针变量可以在不同时间指向栈或堆中的不同数据。
        访问已释放的堆内存或超出作用域的栈内存会导致未定义行为。
 */
#include <iostream>
using namespace std;

void add2(int a, int b) {
    cout << "a+b:" << a + b << endl;
}
//指针的基本使用
void T_Pointer() {
    int a = 100;
    //&:取地址符
    int* p = &a; //&a:取数据a对应的内存地址
    cout << "p:" << p << endl; //p:输出指针所保存的内存地址
    //*:解引用符
    cout << "*p:" << *p << endl; //*P:取指针所保存的内存地址所对应的数据
    cout << endl;
    char b='a';
    char* p2 = &b;
    auto p3 = &b;
    cout << "p2:" << (void*)p2 << endl;//p2:输出指针所保存的内存地址
    cout << "*p2:" << *p2 << endl;//*p2:取指针所保存的内存地址所对应数据
    cout << "p3:" << (void*)p3 << endl;
    cout << "*p3:" << *p3 << endl;
    cout << endl;
}
//函数指针
void Function_Pointer() {
    /*
     p是一个函数指针，它保存了函数 add2 的内存地址。 当输出p时，会显示函数add2在内存中的地址值（通常是十六进制格式）
     函数指针解引用 *p 仍然指向相同的地址，因为函数名本身就是函数的地址。
     */
    auto *p = add2; //函数指针,保存函数add2的地址
    cout << "add2:" << &add2 << endl; //1
    cout << "p:" << p << endl; //函数指针所保存的函数地址
    cout << "*p:" << *p << endl; //:*p 实际上是对函数指针进行解引用，但函数指针解引用后仍然是函数地址，而不是数据
    cout << endl;
    cout << "add2 actual address:" << (void *) add2 << endl; //尝试强制转换为void*查看实际地址
    cout << "&add2 actual address:" << (void *) &add2 << endl;
    cout << endl;
    cout << "p actual address:" << (void *) p << endl;
    cout << "*p actual address:" << (void *) *p << endl;
}
//数组指针
void Array_Pointer() {
    int a[5] = {8, 2, 3, 4, 5};
    int* p = a;
    cout << "a:" << a << endl;//a:输出数组a的起始地址
    cout << "p:" << p << endl;//p:输出指针所保存的数组a的起始地址
    cout << "*p:" << *p << endl;//*p:取指针所保存的数组a的起始地址所对应数据
}
//函数签名指针
void Function_Signature_Pointer() {

}

int main() {
    //T_Pointer();
    //Function_Pointer();
    Array_Pointer();
}
